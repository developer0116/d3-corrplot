<!DOCTYPE html>
<html>
<head lang="en">
  <meta charset="UTF-8">
  <title>d3-corrplot Example</title>

  <script src="../bower_components/d3/d3.min.js"></script>
  <script src="../bower_components/d3.chart/d3.chart.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>
  <script src="../dist/d3-corrplot.js"></script>
  <style>
    body {
      overflow: hidden;
      margin: 0;
      font: 14px "Helvetica Neue";
      padding-left: 80px;
    }

    .background {
      fill: #ffffff;
    }
  </style>
</head>
<body>
<p>Dataset: <select id="dataset">
  <option value="mtcars.json">mtcars</option>
  <option value="movies.json">movies</option>
</select>
</p>
<p>Order: <select id="order">
  <option value="original">Original</option>
  <option value="name">by Name</option>
  <option value="total">by Magnitude</option>
  <option value="aoe">AOE</option>
  <option value="fpc">FPC</option>
</select>
</p>

<script language="javaScript">
  var Corrplot = new Corrplot();
  var orders = {};
  var corrplot = d3.select('body').append('svg')
      .chart('corrplot', {
        transform: function (data) {
          var matrix = data.matrix,
              nodes = data.nodes,
              n = nodes.length;

          // Compute index per node.
          nodes.forEach(function (node, i) {
            node.total = 0;
            matrix[i].forEach(function (z) {
              //TODO: double check this is correct (even if it is this assumes matrix is symmetric)
              node.total += Math.abs(z);
            });
          });

          // Precompute the orders.
          var eigvec = numeric.eig(matrix).E.x;
          orders = {
            original: d3.range(n),
            name: d3.range(n).sort(function (a, b) {
              return d3.ascending(nodes[a].name, nodes[b].name);
            }),
            total: d3.range(n).sort(function (a, b) {
              return nodes[b].total - nodes[a].total;
            }),
            aoe: function () {
              var alpha = d3.range(n).map(function (i) {
                var e1 = eigvec[i][0], e2 = eigvec[i][1];
                return Math.atan(e2 / e1) + (e1 > 0 ? 0 : Math.PI);
              });
              return d3.range(n).sort(function (a, b) {
                return alpha[a] - alpha[b];
              });
            }(),
            fpc: function () {
              var e1 = eigvec.map(function(d) { return d[0]; });
              return d3.range(n).sort(function (a, b) {
                return e1[b] - e1[a];
              });
            }()
          };

          return {nodes: nodes, matrix: matrix};
        }
      })
      .duration(1000);


  d3.select("#order").on("change", function () {
    corrplot.order(orders[this.value]);
  });

  function load(dataset) {
    d3.json('data/' + dataset, function (data) {
      corrplot.draw(data);
    });
  }

  d3.select("#dataset").on("change", function () {
    load(this.value);
  });
  load('mtcars.json');

</script>
</body>
</html>